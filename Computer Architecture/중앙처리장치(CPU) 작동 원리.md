# 중앙처리장치(CPU) 작동 원리

## 중앙처리장치 (CPU)

**CPU**는 컴퓨터에서 가장 핵심적인 역할을 수행하는 부분으로서 '인간의 두뇌'에 해당합니다.


## CPU 구성
**1. 연산 장치**
	- 산술 연산과 논리 연산을 수행한다.
	- 연산에 필요한 데이터를 레지스터에서 가져오고, 연산 결과를 다시 레지스터로 보낸다.
**2. 제어 장치**
	- 명령어를 순서대로 실행할 수 있도록 하는 제어장치
	- 주기억장치(RAM, ROM)에서 프로그램 명령어를 꺼내오고 해독
	- 이 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력 장치로 보낸다.
**3. 레지스터**  
	- 고속 기억장치
	- 명령어 주소, 코드, 연산에 필요한 데이터, 연산 결과 등을 임시로 저장
	- 용도에 따라 범용/특수목적 레지스터로 구분, CPU의 종류에 따라 사용가능한 레지스터 갯수 및 크기가 다름
	- 범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장
	- 특수목적 레지스터 : 특별한 용도로 사용하는 레지스터

## CPU의 동작 과정

![KakaoTalk_20220422_140555789](https://user-images.githubusercontent.com/38287375/164606960-ea8f186c-51ca-4e3f-ac4f-4bc73bb56a9b.jpg)

1. 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램을 읽어온다.
2. 중앙처리장치는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장한다.
3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 내보낸다.
4. 제어장치는 1~3번 과정에서 명령어가 순서대로 실행될 수 있도록 각 장치를 제어한다.

## 명령어 세트

**CPU가 실행할 명령어의 집합**

**연산코드(Operation Code) + 피연산자(Operand)** 로 이루어진다.

- **연산 코드** : 명령어를 실행할 연산을 나타낸다.
	- 연산 기능 : 사칙연산, 시프트, 보수 등의 산술연산과 논리곱, 논리합, 부정 등의 논리연산을 수행한다.
	- 제어 기능 : 조건 분기와 무조건 분기 등을 사용하여 명령어의 실행 순서를 제어한다.
	- 데이터 전달 기능 : 레지스터와 레지스터 사이, 레지스터와 주기억장치 사이에서 데이터를 전달한다.
	- 입출력 기능 : 프로그램과 데이터를 주기억장치에 전달하고, 연산 결과는 출력장치로 전달한다.
- **피연산자** : 연산에 필요한 데이터나 데이터의 저장 위치를 나타낸다.
	- 주소 : 기억장치 혹은 레지스터의 주소가 저장된다.
	- 숫자/문자 : 숫자는 정수, 고정 소수점 수, 부동 소수점 수 및 각각의 코드로 저장되고 문자는 아스키 코드로 저장된다.
	- 논리 데이터 : 참 또는 거짓을 표현할 때 사용되며 비트나 플래그 등으로 저장된다.

## 명령어 사이클 (Instruction Cycle)


중앙처리장치는 프로그램을 실행하기 위해 주기억장치에서 명령어를 순차적으로 인출하여 해독하고 실행하는 과정을 반복한다.

중앙처리장치가 주기억장치에서 **한 번에 하나의 명령어를 인출하여 실행하는 데 필요한 일련의 활동**을 **'명령어 사이클(Instruction Cycle)'** 이라고 한다.

명령어 사이클은 인출 사이클과 실행 사이클로 나뉜다.

![KakaoTalk_20220422_142334531](https://user-images.githubusercontent.com/38287375/164608720-6b2d6d5e-47a4-477c-a6e9-4b0d205b0bd9.jpg)

주기억장치의 지정된 주소에서 하나의 명령어를 가져오고 실행 사이클에서는 명령어를 실행한다. **하나의 명령어 실행이 완료되면 그 다음 명령어에 대한 인출 사이클이 시작된다.**  

**인출 사이클과 실행 사이클에 의한 명령어 처리 과정**
> 인출 사이클에 사용되는 특수 목적 레지스터의 종류와 인출 사이클의 동작 과정

![230B774F575BA66F2C](https://user-images.githubusercontent.com/38287375/164608902-c532ab63-4ac7-44df-bf29-145de465efd1.jpg)

1. 먼저 PC에 저장된 주소를 MAR로 전달한다.
2. 그 이후 MAR에 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어를 인출한다.
3. 인출한 명령어를 MBR에 저장한다. **(중요 포인트 : 다음 명령어를 인출하기 위해 프로그램 카운터(PC)의 값을 증가시킨다는 것)**
4. 마지막으로 메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달한다.

<인출 사이클의 마이크로 연산>
```
T0 : MAR <- PC
T1 : MBR <- M[MAR], PC <- PC + 1
T2: IR <- MBR
```

<ADD addr 명령어 연산>

![2303A14F575BA67031](https://user-images.githubusercontent.com/38287375/164610038-9672c0e2-83e1-4f0f-b186-32c00e8a8d83.jpg)

```
T0 : MAR <- IR(Addr)
T1 : MBR <- M[MAR]
T2 : AC <- AC + MBR
```
T1의 경우 메모리에 저장된 데이터 값을 MBR에 저장한다. 인출 사이클과는 다르게 PC <- PC + 1 이라는 명령어가 존재하지 않는데 이는 이미 인출이 진행이 되고 명령어 실행만 하면 되는 상황이기 때문이다.
즉, 이미 인출이 되어 IR에 MBR의 값이 저장된 상태라는 의미다.
또한 여기서는 이미 어큐뮬레이터(AC)에 저장된 값에 ADD를 한다는 것이 중요하다.


--- 
참고
https://ndb796.tistory.com/7
https://ssungsung.tistory.com/43



 


# 캐시 메모리(Cache Memory)

속도가 빠른 장치와 느린 장치에서 **속도 차이에 따른 병목 현상을 줄이기 위한** 메모리를 말한다.

> CPU는 빠르고, 메모리는 느리다.
> 두 장치의 속도차로 인한 비효율을 보완하기 위해 사용하는 것이 바로 **캐시 메모리**이다.
> 자주 쓰는 데이터를 캐시 메모리에 저장해 메모리에 접근하는 횟수를 줄인다.

![cache](https://user-images.githubusercontent.com/38287375/165347450-864958ef-7680-4f66-97ae-e6a04833632e.jpg)
- 캐시 메모리는 메모리와 CPU 사이에 위치해 있으며 메모리 계층 구조에서 레지스터 다음으로 상위에 위치한다.
- 자주 사용하는 데이터를 CPU와 가까운 위치에 저장해 필요할 때마다 빠르게 꺼내쓸 수 있다. 캐시메모리를 사용하면 CPU가 메모리에 접근하는 횟수를 줄여 성능 향상의 효과를 볼 수 있다.
- 단, 캐시 메모리는 가격이 비싸기 때문에 일반적으로 적은 용량으로 구성된다.


CPU에는 이러한 캐시 메모리가 2~3개 정도 사용된다. (L1, L2, L3 cache memory라고 부른다)

![cache1](https://user-images.githubusercontent.com/38287375/165348718-f6161807-1bdf-43db-a95b-04b33215b5a5.png)

속도와 크기를 기준으로 분류되며 일반적으로 L1 캐시부터 먼저 사용된다.
(CPU에서 가장 빠르게 접근하고 여기서 데이터를 찾지 못하면 L2로 간다.)

**듀얼 코어 프로세서의 캐시 메모리**
각 코어마다 독립된 L1 캐시 메모리를 가지고, 두 코어가 공유하는 L2 캐시 메모리가 내장되어 있다.

만약 L1 캐시가 128kb면, 64/64로 나눠 64kb에 명령어를 처리하기 직전의 명령어를 임시 저장하고, 나머지 64kb에는 실행 후 명령어를 임시 저장한다.

-   L1 : CPU 내부에 존재 (I-Cache(Instruction Cache) + D-Cache(Data Cache)
-   L2 : CPU와 RAM 사이에 존재
-   L3 : 보통 메인 보드에 존재
  
  
CPU는 데이터를 가져오기 위해 캐시메모리 -> 메모리(RAM) -> 보조기억장치(HDD) 순으로 접근한다.

-   **Cache hit - 캐시 적중시**  : 캐시 메모리의 데이터를 CPU 레지스터에 복사한다.
-   **Cache Miss , Memory hit  - 캐시 실패/메모리 적중시** : 메모리에서 데이터를 캐시 메모리에 복사하고 캐시 메모리의 복제된 내용을 CPU 레지스터에 복사한다.
-   **Cache Miss , Memory Miss , HDD hit - 캐시,메모리 실패/HDD 적중시**   : 보조 기억장치에서 필요한 데이터를 메모리에 복사한다. 메모리에 복제된 내용을 캐시 메모리에 복제한다. 캐시 메모리의 복제된 데이터를 CPU 레지스터에 복제한다.

*적중 : 필요한 데이터가 있는 경우
*실패: 필요한 데이터가 없는 경우


## 캐시 메모리 작동 원리

캐시 메모리의 성공 여부는 **참조의 지역성(Locality of reference)** 원리에 달려있다. 지역성은 짧은 시간동안 주소 공간의 일부만 참조되는 경향을 말한다.

단, 지역성은 어디까지나 경향에 대한 것이므로 항상 캐시의 높은 적중률을 보장해주지는 않는다.

**지역성의 종류**
-   **시간 지역성 (temporal locality)**
    -   for, while 같은 반복문에 사용하는 조건 변수처럼 한 번 참조된 데이터는 다시 참조될 가능성이 높음
-   **공간지역성 (spatial locality)**
    -   A[0], A[1]과 같은 연속 접근 시, 참조된 데이터 근처에 있는 데이터가 잠시 후 또 사용될 가능성이 높음.
-   **순차지역성 (sequential locality)**
    -   분기가 발생하지 않는 한 명령어는 메모리에 저장된 순서대로 인출/실행된다.

**보통 명령어(Instruction)은 공간 지역성이 높고 데이터는 시간 지역성이 높다.**


## 캐시 미스(Cache Miss)의 3가지 경우

1.  **Cold miss (Compulsory miss)**
	
	-   해당 메모리 주소를 처음 불러서 나는 miss

2.  **Conflict miss**

	-   캐시 메모리에 A,B데이터를 저장해야 하는데, A,B가 같은 캐시 메모리 주소에 할당되어 있어서 나는 miss
	-   ex) 항상 핸드폰과 열쇠를 오른쪽 주머니에 넣고 다니는데, 잠깐 친구가 준 물건을 받느라 손에 들고 있던 핸드폰을 가방에 넣었음. 그 이후 핸드폰을 찾으려 오른쪽 주머니에서 찾는데 없는 상황

3.  **Capacity miss**

	-   캐시 메모리의 공간이 부족해서 나는 miss (Conflict는 주소 할당의 문제, Capacity는 공간의 문제)

캐시 크기를 키워서 문제를 해결하려하면, 캐시 접근 속도가 느려지고 파워를 많이 먹는 단점이 생긴다.

## 구조 및 작동 방식

- Direct Mapped Cache

![cache2](https://user-images.githubusercontent.com/38287375/165351010-36ec44ea-f09a-4318-b4f8-d53ae0d5d8f5.png)


   - 가장 기본적인 구조.  
   - DRAM의 여러 주소가 캐시 메모리의 한 주소에 대응되는 다대일 방식. 위의 그림에서 메모리 공간이 32개이고 캐시 메모리 공간은 8개인 상황.  
	ex) 00000,01000,10000,11000인 메모리 주소는 000 캐시 메모리 주소에 맵핑  
   - 이때 000이 '인덱스 필드', 인덱스 제외한 앞의 나머지 00,01,10,11를 태그 필드라고한다.  
   - 이처럼 캐시메모리는 **인덱스 필드 + 태그 필드 + 데이터 필드**로 구성된다.  
   - 간단하고 빠른 장점이 있지만, Conflict Miss가 발생하는 것이 단점이다.  
위 사진처럼 같은 색깔의 데이터를 동시에 사용할 때 발생한다.

-   **Fully Associative Cache**  
    - 비어있는 캐시 메모리가 있으면, 마음대로 주소를 저장하는 방식  
    저장할 때는 매우 간단하지만, 찾을 때가 문제이다.  
    - 조건이나 규칙이 없어서 특정 캐시 Set안에 있는 모든 블럭을 한번에 찾아 원하는 데이터가 있는지 검색해야 한다.  
    - CAM이라는 특수한 메모리 구조를 사용해야 하지만 매우 비싸다..
    
-   **Set Associative Cahce**
    
    -   Direct + Fully 방식.
    -   특정 행을 지정하고 그 행 안의 어떤 열이든 비어있을 때 저장하는 방식.
    -   Direct에 비해 검색 소도는 느리지만 저장이 빠르고 Fully에 비해 느린 대신 검색이 빠른 중간형이다.


---

참고
https://velog.io/@jaeyunn_15/OS-%EC%BA%90%EC%8B%9C-%EB%A9%94%EB%AA%A8%EB%A6%ACCache-Memory

https://zion830.tistory.com/46
# 인터럽트

## 인터럽트란? (Interrupt)

> OS는 서로 다른 일을 하는 수많은 하드웨어를 사용한다. 이런 장치들은 동기적으로 구동되는데, 이는 각각 동작이 완료될 때까지 기다려야 하므로 **"아무것도 하지 않으면서 바쁜 상태**로 많은 시간을 소비하게 된다. 이 때, **인터럽트**를 사용하여 한번에 하나의 명령만 수행할 수 있는 CPU의 한계성을 보완할 수 있다.

프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것  

지금 수행 중인 일보다 더 중요한 일(ex. 입출력, 우선 순위 연산 등)이 발생하면 그 일을 먼저 처리하고 나서 하던 일을 계속해야한다.

## 인터럽트의 종류

### 1. 외부 인터럽트

CPU 코어 외부에서 어떤 일이 발생한 것을 **전기적인 신호**로 CPU에게 통지하는 경우

- **정전/전원이상 인터럽트** : 정전 또는 전원공급의 이상으로 인한 인터럽트
- **기계고장 인터럽트** : CPU 및 기타 하드웨어의 오류로 인한 인터럽트
- **외부 인터럽트** : Timer나 Operator로 인한 인터럽트
- **입출력 인터럽트** : 입출력의 종료나 입출력의 오류로 인한 인터럽트

### 2. 내부 인터럽트

CPU 코어 외부에서 인터럽트를 거는 경우가 일반적이지만, **CPU 내부에서** 실행하면서 인터럽트에 걸리는 경우

- **프로그램 검사 인터럽트** : Divide by Zero, Overflow/Underflow 등

### 3. 소프트웨어 인터럽트

사용자가 프로그램을 실행시키거나 Supervisor(=OS)를 호출하는 동작을 수행하는 경우

- **SVC(Supervisor Call) 인터럽트** : OS를 호출하는 동작을 수행하는 경우

## 인터럽트 처리 과정


> 요청 -> 중단 -> 보관 -> 처리 -> 재개

1.  인터럽트 요청
    
2.  프로그램 실행 중단
    
    -   현재 실행중이던  `Micro Operation`  까지 수행
3.  현재 실행중인 프로그램 상태를 **PCB(Process Control Block)** 보관
    
    -   `Interrupt Vector`  를 읽어  `ISR`  주소값을 얻음
    -   ISR 로 점프 (이 때, PC 값은 자동 대피 저장됨)
    -   현재 진행중인 프로그램의 레지스터를 대피함
4.  인터럽트 서비스 루틴 처리
    
    -   인터럽트 원인을 파악하고 실질적인 작업 수행
    -   서비스 루틴 수행 중, 우선순위가 더 높은 인터럽트가 발생하면 재귀적으로 1~5 과정 수행
5.  상태 복구
    
    -   해당 작업을 다 처리하면, 대피시킨 레지스터를 복원한다
    -   ISR 끝에  `RETI`  명령어에 의해 인터럽트 해제
    -   명령어가 실행되면, PC 값을 복원하여 이전 실행 위치로 복원


## 인터럽트 우선순위

`정전•전원이상 인터럽트` > `기계고장 인터럽트` > `외부 인터럽트` > `입출력 인터럽트` > `프로그램 검사 인터럽트` > `SVC(SuperVisor Call)`


## 우선순위 판별 방법

-   폴링 (Polling)
    
    > 가장 높은 인터럽트로 부터 요청 플래그를 검사하여  `ISR`  을 수행하는  `소프트웨어적인 방법`  이다. 인터럽트를 조사하는 비용이 들어 반응시간이 느리지만, 하드웨어를 추가할 필요가 없어 회로가 간단하다는 장점을 지니고 있다.
    
-   데이지 체인 (Daisy Chain)
    
    > 어디에 인터럽트가 발생하는지 확인하는 회로를 직렬로 연결하는  `하드웨어적인 방법`  이다



---
참조

https://hibee.tistory.com/264

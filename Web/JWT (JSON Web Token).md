# JWT (JSON Web Token)

> 토큰 기반 인증 시스템은 클라이언트가 서버에 접속을 하면 서버에서 해당 클라이언트에게 인증되었다는 의미로 **'토큰'을 부여**한다.
>
 > 이 토큰은 **유일하며** 토큰을 발급받은 클라이언트는 또 다시 **서버에 요청을 보낼 때 요청 헤더에 토큰을 심어서 보낸다.**
>
> 그러면 서버에서는 클라이언트로부터 받은 토큰을 서버에서 제공한 토큰과의 일치 여부를 체크하여 인증 과정을 처리하게 된다.

## Token 인증

기존의 세션 기반 인증은 서버가 파일이나 데이터베이스에 세션정보를 가지고 있어야 하고 이를 조회하는 과정이 필요하기 때문에 많은 오버헤드가 발생한다.

하지만 토큰은 세션과는 달리 서버가 아닌 클라이언트에 저장되기 때문에 메모리나 스토리지 등을 통해 세션을 관리했던 서버의 부담을 덜 수 있다.

토큰 자체에 데이터가 들어있기 때문에 클라이언트에서 받아 위조되었는지 판별만 하면 된다.

### Token 인증 방식

1. 사용자가 아이디와 비밀번호 로그인을 한다.
2. 서버 측에서 사용자(클라이언트)에게 유일한 토큰을 발급한다.
3. 클라이언트는 서버 측에서 전달받은 토큰을 쿠키나 스토리지에 저장해 두고, 서버에 요청할 때마다 해당 토큰을 HTTP 요청 헤더에 포함시켜 전달한다.
4. 서버는 전달받은 토큰을 검증하고 요청에 응답한다. (토큰에는 요청한 사람의 정보가 담겨있기 때문에 서버는 DB를 조회하지 않고 누가 요청하는지 알 수 있다.)

### Token 방식의 장/단점

#### 장점

- Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
- 인증 정보에 대한 별도의 저장소가 필요없다.
- 클라이언트 인증 정보를 저장하는 세션과 다르게 서버는 무상태(Stateless)가 된다.
- 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다.
- 모바일 어플리케이션 환경에서도 잘 동작한다. (세션은 모바일 사용 불가)
- OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹 서비스에서도 로그인을 할 수 있다.

#### 단점

- 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해질 수 있다.
- Payload 자체는 암호화되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
- 토큰을 탈취당하면 대처하기 어렵다. (따라서 사용 기간 제한을 설정하는 식으로 극복한다.)

<br />

## JWT (JSON Web Token)

JWT란 **인증에 필요한 정보들을 암호화시킨 JSON 토큰**을 의미한다.

JWT 기반 인증은 JWT 토큰(Access Token)을 HTTP 헤더에 실어 서버가 클라이언트를 식별하는 방식이다.

<br />

## JWT 구조

JWT는 `.` 을 구분자로 3가지의 문자열로 구성되어 있다.

 `aaaa.bbbb.cccc ` 의 구조로 `.`을 기준으로 좌측부터 헤더(Header), 내용(Payload), 서명(Signature)을 의미한다.

### 헤더 (Header)

```
{
	"typ" : "JWT",
	"alg" : "HS256"
}
```

- typ : 토큰의 타입을 지정
- alg : 해싱 알고리즘 지정 (ex : HMAC, SHA256, RSA)

### 정보 (Payload)

```
{
	"sub" : "1234567890",
	"iat" : 124342122
}
```
Payload 부분에는 토큰을 담을 정보(데이터 및 권한)가 들어있다. 정보의 한 조각을 **클레임(Claim)** 이라고 부르고, key/value의 한 쌍으로 이뤄져있다. 토큰에는 여러개의 클레임들을 넣을 수 있지만 너무 많아질 경우 토큰의 길이가 길어질 수 있다.

#### Registered Claims

> 등록된 클레임은 서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보들을 담기 위해 이름이 이미 정해진 클레임이다. 등록된 클레임의 사용은 모두 선택적(Optional)이며, 이에 포함된 클레임 이름은 다음과 같다.

- `iss` : 토큰 발급자 (issuer)
- `sub` : 토큰 제목 (subject)
- `aud` : 토큰 대상자 (audience)
- `exp` : 토큰의 만료 시간(expiration), 시간은 NumericDate 형식으로 되어있어야 하며 언제나 현재 시간보다 이후로 설정되어 있어야 한다.
- `nbf` : Not before을 의미하며, 토큰의 활성 날짜와 비슷한 개념이다. 마찬가지로 NumericDate 형식으로 날짜를 지정하며 이 날짜가 지나기 전까지는 토큰이 처리되지 않는다.
- `iat` : 토큰이 발급된 시간 (issued at), 이 값을 사용하여 토큰의 age가 얼마나 되었는지 판단할 수 있다.
- `jti` : JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위해 사용된다. 일회용 토큰에 사용하면 유용하다.

#### Public Claims

> 공개 클레임은 충돌이 방지된 (Collision-resistant) 이름을 가지고 있어야 한다. 충돌을 방지하기 위해서는 클레임 이름을 URI 형식으로 짓는다.

#### Private Claims

> 비공개 클레임은 양 측간에 (보통 클라이언트 <-> 서버) 합의하에 사용되는 클레임 이름이다. 공개 클레임과는 달리 이름이 중복되어 충돌이 될 수 있으니 사용할 때 유의해야 한다.

### 서명 (Signature)

```
eusfFdj0sdffdjhsRfg2sd9dSDFddss.DjsdkfsdheEdf9SDF2SgdfssS34.Sdfsdjfh-34sjfdjhsGvdj
```
서명은 헤더(Header), 정보(Payload)를 대상으로 Base64 URL-safe Encode를 적용하고 해싱한 뒤 이를 대상으로 비밀키로 서명한 것이다.
비밀키와 공개키는 ECDSA를 사용하여 생성하게 될 것이다.
비밀키로 서명하게 되면 공개키를 통해 검증을 거치게 될 것이다.

<br />

## JWT를 이용한 인증 과정


![Frame 1](https://user-images.githubusercontent.com/38287375/181177388-f0c2ed8e-74f9-48db-add5-2f88a5b13cf3.png)

1. 사용자가 ID, PW를 입력하여 서버에 로그인 인증을 요청한다.
2. 서버에서 클라이언트로부터 인증 요청을 받으면 Header, PayLoad, Signature를 정의한다. 이후 각각 Base64로 한 번 더 암호화하여 JWT를 생성하고 이를 쿠키에 담아 클라이언트에게 발급한다.
3. 클라이언트는 서버로부터 받은 JWT를 로컬 스토리지에 저장한다. (쿠키나 다른 곳에 저장할 수도 있음)
4. 서버가 할 일은 클라이언트가 Header에 담아서 보낸 JWT가 내 서버에서 발행한 토큰인지 일치 여부를 확인하여 일치한다면 인증을 통과시켜주고 아니라면 통과시키지 않으면 된다. 인증이 통과되었으므로 PayLoad에 들어있는 유저의 정보들을 select해서 클라이언트에 돌려준다.
5. 클라이언트가 서버에 요청을 했는데, 만일 Access Token의 시간이 만료되면 클라이언트는 Refresh Token을 이용해서 
6. 서버로부터 새로운 Access Token을 발급 받는다.

<br />

---

참조

https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC

https://github.com/gyoogle/tech-interview-for-developer/blob/master/Web/JWT(JSON%20Web%20Token).md


